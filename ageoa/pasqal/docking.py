"""Pasqal-inspired molecular docking atoms.

These wrappers are deterministic and self-contained so they can run in tests
without external quantum backends.
"""

from __future__ import annotations

from typing import Dict, List, Set

import icontract
import networkx as nx  # type: ignore

from ageoa.ghost.registry import register_atom
from ageoa.pasqal.docking_state import MolecularDockingState
from ageoa.pasqal.docking_witnesses import (
    witness_graph_transformer,
    witness_quantum_mwis_solver,
    witness_sub_graph_embedder,
)


@register_atom(witness_sub_graph_embedder)
@icontract.require(lambda subgraph_quantity: subgraph_quantity > 0, "subgraph_quantity must be positive")
@icontract.ensure(lambda result: isinstance(result, tuple) and len(result) == 2, "Result must be a (mappings, state) tuple")
@icontract.ensure(lambda result: isinstance(result[0], list), "First element must be a list of mappings")
def sub_graph_embedder(
    current_graph: nx.Graph,
    subgraph_quantity: int,
    state: MolecularDockingState,
) -> tuple[list[dict[int, int]], MolecularDockingState]:
    """Extract deterministic embeddable node mappings from a graph.

    Args:
        current_graph: Input networkx Graph.
        subgraph_quantity: Maximum number of subgraph mappings to extract.
        state: Current MolecularDockingState.

    Returns:
        Tuple of (mappings, new_state) where mappings is a list of
        node-to-index dictionaries.
    """
    nodes = sorted(current_graph.nodes())
    limit = min(subgraph_quantity, len(nodes))

    mappings: list[dict[int, int]] = []
    for idx in range(limit):
        mappings.append({int(nodes[idx]): idx})

    new_state = state.model_copy(update={"graph": current_graph})
    return mappings, new_state


@register_atom(witness_graph_transformer)
@icontract.require(lambda mapping: len(mapping) > 0, "mapping must not be empty")
@icontract.ensure(lambda result: isinstance(result, tuple) and len(result) == 2, "Result must be a (graph, state) tuple")
@icontract.ensure(lambda result: isinstance(result[0], nx.Graph), "First element must be a networkx Graph")
def graph_transformer(
    current_graph: nx.Graph,
    lattice: nx.Graph,
    mapping: dict[int, int],
    state: MolecularDockingState,
) -> tuple[nx.Graph, MolecularDockingState]:
    """Map a subgraph onto lattice coordinates deterministically.

    Args:
        current_graph: Source networkx Graph.
        lattice: Target lattice networkx Graph.
        mapping: Dictionary mapping source node IDs to lattice node IDs.
        state: Current MolecularDockingState.

    Returns:
        Tuple of (transformed_graph, new_state) where transformed_graph
        is a new networkx Graph with nodes mapped to lattice coordinates.
    """
    transformed = nx.Graph()

    mapped_nodes = sorted(set(mapping.values()))
    transformed.add_nodes_from(mapped_nodes)

    for u, v in current_graph.edges():
        if u not in mapping or v not in mapping:
            continue
        mu = mapping[u]
        mv = mapping[v]
        if mu == mv:
            continue

        # Keep only edges allowed by lattice when both nodes exist there.
        if lattice.number_of_nodes() == 0:
            transformed.add_edge(mu, mv)
        elif lattice.has_node(mu) and lattice.has_node(mv):
            if lattice.number_of_edges() == 0 or lattice.has_edge(mu, mv):
                transformed.add_edge(mu, mv)

    new_state = state.model_copy(update={
        "graph": transformed,
        "lattice": lattice,
    })
    return transformed, new_state


@register_atom(witness_quantum_mwis_solver)
@icontract.require(lambda mis_sample_quantity: mis_sample_quantity > 0, "mis_sample_quantity must be positive")
@icontract.ensure(lambda result: isinstance(result, tuple) and len(result) == 2, "Result must be a (solutions, state) tuple")
@icontract.ensure(lambda result: isinstance(result[0], list), "First element must be a list of independent sets")
def quantum_mwis_solver(
    graph: nx.Graph,
    lattice_id_coord_dic: dict[int, tuple[float, float]],
    mis_sample_quantity: int,
    state: MolecularDockingState,
) -> tuple[list[set[int]], MolecularDockingState]:
    """Deterministic Maximum Weight Independent Set (MWIS) heuristic used as a combinatorial optimization solver placeholder.

    Args:
        graph: Input networkx Graph.
        lattice_id_coord_dic: Dictionary mapping lattice node IDs to (x, y) coordinates.
        mis_sample_quantity: Number of independent set samples to generate.
        state: Current MolecularDockingState.

    Returns:
        Tuple of (solutions, new_state) where solutions is a list of
        sets of node IDs forming independent sets.
    """
    # Greedy independent set by (degree, node_id).
    ordered_nodes = sorted(graph.nodes(), key=lambda n: (graph.degree[n], n))

    selected: set[int] = set()
    blocked: set[int] = set()
    for node in ordered_nodes:
        if node in blocked:
            continue
        selected.add(int(node))
        blocked.add(node)
        blocked.update(graph.neighbors(node))

    solutions: List[Set[int]] = [set(selected) for _ in range(mis_sample_quantity)]

    new_state = state.model_copy(update={
        "graph": graph,
        "lattice_id_coord_dic": lattice_id_coord_dic,
    })
    return solutions, new_state
